/*
 * Node objects to store evolutioned rotational states in the static member tree structures
 *
 * Copyright (C) 2020  Robert Ikanov <robert.ikanov@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
#ifndef CUBE_NODE__H
#define CUBE_NODE__H

#include <cube_framework.h>

template<unsigned int N>
class CNode
{
  static CNode<N>* Tree;
  static CNode<N>* NextNode;
  static byte      Depth;
  static long*     IndexOFLevel;
  
  const CNode<N>*  m_parent;
  CFramework<N>    m_data;
  byte             m_rotID;
  
  // create root
  CNode( void );
    
  // create a new node from a parent node by a rotational operation
  CNode( const CNode<N>* aParent, byte aRotID ); 
  
  // calculate the number of nodes ( in a tree of any size )
  static void initIndices();
  
  // insert children nodes into the tree
  void extend() const;

public:
  
  // build a new tree of a given size
  static void Initialize ( int depth );
  static void OnExit     ( void      );
  
  // cube frameworks generated by n rotations starts from here:
  static const CNode< N >* StartNode( int level = 0 ); 
  
  const CNode<N>& operator= ( const CNode<N>& C )
  {
        m_parent = C.parent();
        m_rotID  = C.rotID();
        m_data   = C.data();
  }

  // Queries
  byte                 rotID () const { return m_rotID;  }
  const CNode<N>*      parent() const { return m_parent; }
  const CFramework<N>& data  () const { return m_data;   }
  
  static const CNode<N>* getNode( int id ) { return Tree + id; }
  static const CNode<N>* getRoot( void )   { return Tree;      }
};

 // set default values to static members
//  ------------------------------------

// Tree
  template<unsigned int N>
  CNode<N>* CNode<N>::Tree     = nullptr;

// NextNode
  template<unsigned int N>
  CNode<N>* CNode<N>::NextNode = nullptr;

// IndexOFLevel
  template<unsigned int N>
  long* CNode<N>::IndexOFLevel = nullptr;

// Depth
  template<unsigned int N>
  byte CNode<N>::Depth         = 0;

 // Constructors
//  ------------

// root
template<unsigned int N>
CNode<N>::CNode()
  : m_parent( nullptr )
  , m_rotID ( 9 * N /* not exist */ )
  , m_data  ( CFramework<N>() )
{
}

// inner node (having a parent node)
template<unsigned int N>
CNode<N>::CNode( const CNode<N>* aParent, byte aRotID )
  : m_parent( aParent )
  , m_rotID ( aRotID )
  , m_data  ( m_parent->m_data, aRotID )
{
  
}

 // Building trees
//  -------------- 

template<unsigned int N> 
void CNode<N>::Initialize( int depth )
{
  if ( depth == Depth )
  {
    // nothing to do
    return;
  }
  Depth = depth;
  
  if ( IndexOFLevel == nullptr )
  {
    // build a new tree
    initIndices();
  }
  
  // allocate a new tree
  Tree = new CNode<N> [ IndexOFLevel[ Depth + 1 ] ];
  NextNode = Tree;
  
  // create root
  CNode<N> root;
  *( NextNode++ ) = CNode<N> ();
  
  clog( "tree" );
  
  // extend root
  Tree -> extend();
}

// calculate the width of levels
template<unsigned int N> void CNode<N>::initIndices()
{
  // create a new array
    IndexOFLevel = new long [9];
  
  // calculate the constant ratio of the iteration
    const int redundancy = 3 * 3 * ( N + 1 ) * N / 2;
    const int iter = ( 9 * N ) * ( 9 * N ) - redundancy;
  
  // Initialize the recursion
    IndexOFLevel[0] = 0;         // level 0 : empty tree
    IndexOFLevel[1] = 1;         // level 1 : root
    IndexOFLevel[2] = 3 * N * 3; // level 2 : (3 axes) x (N slices) x (3 possible turns)
  
  // calculate the number of nodes in a given level recursively
    for ( int dep = 3; dep < 9; ++dep )
        IndexOFLevel[dep] = IndexOFLevel[dep-2] * iter;
  
  // number of nodes in a tree = sum of levels
    for ( int dep = 1; dep < 9; ++dep )
        IndexOFLevel[dep] += IndexOFLevel[dep-1];
}

// get starter nodes of levels
template<unsigned int N> 
const CNode<N> * CNode<N>::StartNode( int level )
{
  return Tree + IndexOFLevel[ level ]; 
}

// extend node: insert its children to the tree recursively
template<unsigned int N> 
void CNode<N>::extend() const
{
  static int buildingDepth = 0;
  
  ++buildingDepth;
  
  const Axis skipAxis  = getAxis  <N> ( m_rotID );
  const byte skipSlice = getSlice <N> ( m_rotID ); 
  
  // insert children into the tree and skip redundancy with the parent
  const CNode<N>* insertedNodes = NextNode;
  for ( Axis axis : { _X, _Y, _Z } )
  {
    for ( byte slice = 0; slice < N; ++slice )
    {
      if ( axis == skipAxis && slice <= skipSlice )
      {
        continue;
      }
      for ( byte turn: { 1, 2, 3 } )
      {
        *( NextNode++ ) = CNode<N> ( this, getRotID<N> ( axis, slice, turn ) );
      }
    }
  }
  const CNode<N>* extendedNodes = NextNode;
  
  // extend children recursively
  if ( buildingDepth < Depth )
  {
    while ( insertedNodes != extendedNodes )
    {
      ( insertedNodes++ ) -> extend();
    }
  }
  
  clog_ ( '\r', NextNode - Tree );
  --buildingDepth; // go upward
}

 // release sources
//  ---------------

template<unsigned int N> 
void CNode<N>::OnExit()
{
  delete[] Tree;
  delete[] IndexOFLevel;
  
  Tree         = nullptr;
  IndexOFLevel = nullptr;
}

#endif
