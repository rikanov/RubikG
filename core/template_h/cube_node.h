/*
 * Node objects to store evolutioned rotational states in the static member tree structures
 *
 * Copyright (C) 2020  Robert Ikanov <robert.ikanov@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
#ifndef CUBE_NODE__H
#define CUBE_NODE__H

#include <cube_framework.h>

#define all_turns( axis, layer, turn )      \
  for ( Axis axis : { _X, _Y, _Z } )          \
    for ( byte layer = 0; layer < N; ++layer ) \
      for ( byte turn: { 1, 2, 3 } ) 
        
template<unsigned int N>
class CNode
{
  static CNode<N>* Root;
  static byte      Depth;
  static long*     IndexOFLevel;
  
  const CNode<N>*  m_parent;
  CFramework<N>    m_data;
  byte             m_rotID;
  
  // create root
  CNode( void );
    
  // create a new node from a parent node by a rotational operation
  CNode( const CNode<N>* aParent, byte aRotID ); 
  
  // calculate the number of nodes ( in a tree of any size )
  static void initIndices();

  void storeRotID( byte* id ) const;
  
public:
  
  // build a new tree of a given size
  static void Initialize ( int depth );
  static void OnExit     ( void      );
  
  // cube frameworks generated by n rotations starts from here:
  static const CNode< N >* StartNode( int level = 0 ); 
  
  const CNode<N>& operator= ( const CNode<N>& C )
  {
    m_parent = C.parent();
    m_rotID  = C.rotID();
    m_data   = C.data();
  }
  
  // get path recursively
  const byte* getPath() const;
  
  // Queries
  byte                 rotID () const { return m_rotID;  }
  const CNode<N>*      parent() const { return m_parent; }
  const CFramework<N>& data  () const { return m_data;   }
  
  static const CNode<N>* getNode( int id ) { return Root + id; }
  static const CNode<N>* getRoot( void )   { return Root;      }
};

 // set default values to static members
//  ------------------------------------

// Tree
  template<unsigned int N>
  CNode<N>* CNode<N>::Root     = nullptr;

// IndexOFLevel
  template<unsigned int N>
  long* CNode<N>::IndexOFLevel = nullptr;

// Depth
  template<unsigned int N>
  byte CNode<N>::Depth         = 0;

 // Constructors
//  ------------

// root
template<unsigned int N>
CNode<N>::CNode()
  : m_parent( nullptr )
  , m_rotID ( 9 * N + 1 /* not exist */ )
  , m_data  ( CFramework<N>() )
{
}

// inner node (having a parent node)
template<unsigned int N>
CNode<N>::CNode( const CNode<N>* aParent, byte aRotID )
  : m_parent( aParent )
  , m_rotID ( aRotID )
  , m_data  ( m_parent->m_data, aRotID )
{
  
}

 // Building trees
//  -------------- 

template<unsigned int N> 
void CNode<N>::Initialize( int depth )
{
  if ( depth == Depth )
  {
    // nothing to do
    return;
  }
  Depth = depth;
  
  if ( IndexOFLevel == nullptr )
  {
    // build a new tree
    initIndices();
  }
  
  // allocate a new tree
    Root  = new CNode<N> [ IndexOFLevel[ Depth + 1 ] ];
    
  // create root
    *Root = CNode<N>();
  
  // extend recursively
  // while having not extended nodes beside leaf nodes 
  //     get the next node from LIFO
  //     extend it --> put the children nodes into a LIFO
  
  auto Out = Root;
  auto In  = Root + 1;
  auto End = Root + IndexOFLevel[ Depth ];
  
  while ( Out != End )
  {
    // extend
    
    const Axis skipAxis  = getAxis  <N> ( Out -> m_rotID );
    const byte skipLayer = getLayer <N> ( Out -> m_rotID ); 
    
    // insert children into the tree and skip redundancy with the parent
    all_turns( axis, layer, turn )
    {
      if ( axis == skipAxis && layer <= skipLayer )
      {
        continue;
      }
      *( In++ ) = CNode<N> ( Out, getRotID<N> ( axis, layer, turn ) );
    }
  
    ++ Out; 
  }
  clog( "teszt root: ", toString<N>( Root -> m_rotID ) );
  clog( "teszt 1.  : ", toString<N>( ( Root + 1 ) -> m_rotID ) );
  clog( Root  -> m_parent == nullptr );
}

// calculate the width of levels
template<unsigned int N> void CNode<N>::initIndices()
{
  // create a new array
    IndexOFLevel = new long [9];
  
   // N(i) = N(i-2) * ratio
  //  ----------------------  
  int ratio = 0;
  all_turns( axis, layer, turn )
  {
    int countLayers  = 3 * N;       // three axes X N layers
        countLayers -= layer + 1 ;  // do not turn former layers on the same axis
    
    ratio += 3 * countLayers;       // each layers has three possible turns
  }
  
  // Initialize the recursion
    IndexOFLevel[0] = 0;         // level 0 : empty tree
    IndexOFLevel[1] = 1;         // level 1 : root
    IndexOFLevel[2] = 3 * N * 3; // level 2 : (3 axes) x (N slices) x (3 possible turns)
  
  // calculate the number of nodes in a given level recursively
    for ( int dep = 3; dep < 9; ++dep )
        IndexOFLevel[dep] = IndexOFLevel[dep-2] * ratio;
  
  // number of nodes in a tree = sum of levels
    for ( int dep = 1; dep < 9; ++dep )
        IndexOFLevel[dep] += IndexOFLevel[dep-1];
}

// get starter nodes of levels
template<unsigned int N> 
const CNode<N> * CNode<N>::StartNode( int level )
{
  return Root + IndexOFLevel[ level ]; 
}

// get path ToDO: smart pointer !!!!
template<unsigned int N> 
const byte * CNode<N>::getPath() const
{
  byte *ret = new byte [ Depth ]();
  storeRotID( ret );
  return ret;
}

template<unsigned int N> 
void CNode<N>::storeRotID(byte* id) const
{ 
  if ( m_parent ) 
  { 
    m_parent->storeRotID( id +1 );
    *id = m_rotID; if ( m_rotID == 0 ) clog ( "NULL!" );
  }
}


 // release sources
//  ---------------

template<unsigned int N> 
void CNode<N>::OnExit()
{
  delete[] Root;
  delete[] IndexOFLevel;
  
  Root         = nullptr;
  IndexOFLevel = nullptr;
}

#endif
